/**\r\n * Global API Utility\r\n * Ensures consistent API paths and prevents double prefixes.\r\n */\r\n\r\nconst isApp = window.location.protocol === 'file:' || window.location.protocol === 'capacitor:' || window.location.hostname === 'localhost';\r\nconst API_HOST = isApp ? \"https://mial.be\" : \"\";\r\nconst API_BASE = API_HOST + \"/portal-api\";\r\nwindow.API_HOST = API_HOST;\r\n\r\n/**\r\n * Constructs a normalized API URL.\r\n * Usage: fetch(apiUrl('/auth/login')) -> fetch('/portal-api/auth/login')\r\n * \r\n * Logic:\r\n * 1. Normalize slashes.\r\n * 2. Strip API_BASE if present at start.\r\n * 3. Prepend API_BASE.\r\n * \r\n * @param {string} path - The endpoint path (e.g., '/auth/login', 'me')\r\n * @returns {string} - The full API URL\r\n */\r\nfunction apiUrl(path) {\r\n    if (!path) return API_BASE;\r\n\r\n    // 1. Normalize to ensure string and leading slash\r\n    let p = String(path).trim();\r\n    if (!p.startsWith('/')) {\r\n        p = '/' + p;\r\n    }\r\n\r\n    // 2. Strip existing API_BASE prefix if present (to avoid double prefixing)\r\n    // We check for \"/portal-api\" at the start\r\n    if (p.startsWith(API_BASE)) {\r\n        p = p.substring(API_BASE.length);\r\n        // ensure remaining starts with / if not empty\r\n        if (p && !p.startsWith('/')) p = '/' + p;\r\n    }\r\n\r\n    // 3. Construct Final URL\r\n    // If p became empty or just slash, handle gracefully, though usually expect subpath\r\n    if (p === '/' || p === '') return API_BASE;\r\n\r\n    // Ensure final p starts with / for clean concatenation logic, though we stripped it above?\r\n    // Actually if we stripped /portal-api, we might have /me or me.\r\n    // Let's ensure slash.\r\n    if (!p.startsWith('/')) p = '/' + p;\r\n\r\n    return API_BASE + p;\r\n}\r\n\r\n// Expose globally\r\nwindow.apiUrl = apiUrl;\r\nwindow.API_BASE = API_BASE;\r\n\r\n// =========================================================\r\n// üîê CSRF Protection (Double Submit Cookie)\r\n// =========================================================\r\n\r\n/**\r\n * Extracts a cookie value by name.\r\n * @param {string} name - Cookie name to extract\r\n * @returns {string|null} - Cookie value or null if not found\r\n */\r\nfunction getCookie(name) {\r\n    const cookies = document.cookie.split(';');\r\n    for (const cookie of cookies) {\r\n        const [key, ...valueParts] = cookie.trim().split('=');\r\n        if (key === name) {\r\n            return decodeURIComponent(valueParts.join('='));\r\n        }\r\n    }\r\n    return null;\r\n}\r\nwindow.getCookie = getCookie;\r\n\r\n/**\r\n * Enhanced fetch that automatically injects CSRF token\r\n * for all mutating requests (POST, PUT, DELETE, PATCH).\r\n * \r\n * Drop-in replacement for fetch() ‚Äî all existing code works unchanged.\r\n * \r\n * @param {string|Request} url - URL or Request object\r\n * @param {object} [options] - Fetch options\r\n * @returns {Promise<Response>}\r\n */\r\nconst _originalFetch = window.fetch;\r\n\r\nwindow.fetch = function(url, options = {}) {\r\n    const method = (options.method || 'GET').toUpperCase();\r\n    \r\n    // Only inject CSRF for mutating methods\r\n    if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method)) {\r\n        const csrfToken = getCookie('csrf_token');\r\n        if (csrfToken) {\r\n            // Merge headers (preserve existing ones)\r\n            const existingHeaders = options.headers || {};\r\n            \r\n            if (existingHeaders instanceof Headers) {\r\n                if (!existingHeaders.has('X-CSRF-Token')) {\r\n                    existingHeaders.set('X-CSRF-Token', csrfToken);\r\n                }\r\n            } else if (Array.isArray(existingHeaders)) {\r\n                // Headers as array of [key, value] pairs\r\n                const hasCSRF = existingHeaders.some(([k]) => k.toLowerCase() === 'x-csrf-token');\r\n                if (!hasCSRF) {\r\n                    existingHeaders.push(['X-CSRF-Token', csrfToken]);\r\n                }\r\n            } else {\r\n                // Headers as plain object (most common case)\r\n                if (!existingHeaders['X-CSRF-Token']) {\r\n                    existingHeaders['X-CSRF-Token'] = csrfToken;\r\n                }\r\n            }\r\n            \r\n            options.headers = existingHeaders;\r\n        }\r\n    }\r\n    \r\n    return _originalFetch.call(window, url, options);\r\n};\r\n\r\nconsole.log('üîê CSRF: fetch() interceptor active ‚Äî X-CSRF-Token auto-injected on POST/PUT/DELETE/PATCH');\r\n\r\n// =========================================================\r\n// Standard Actions\r\n// =========================================================\r\n\r\n/**\r\n * Standard Logout\r\n * Calls the API to clear cookies, then redirects to login.\r\n */\r\nasync function doLogout() {\r\n    try {\r\n        await fetch(apiUrl('/auth/logout'), {\r\n            method: 'POST',\r\n            credentials: 'include'\r\n        });\r\n    } catch (e) {\r\n        console.warn('Logout fetch error', e);\r\n    } finally {\r\n        window.location.href = '/Connexion.html';\r\n    }\r\n}\r\nwindow.doLogout = doLogout;\r\n
